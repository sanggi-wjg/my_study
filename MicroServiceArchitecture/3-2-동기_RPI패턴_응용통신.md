# MSA 프로세스 통신 2

## 부분 통신 실패 : 회로 차단기 패턴
항상 서비스는 실패할 가능성에 대해  오픈 마인드다.  
한개 서비스 호출 불가는 전체 서비스에 대해 영향을 미침으로 서비스 부분 실패가 전체에 영향 가지 않도록  
설계를 해야 한다. 

### RPI 프록시 설계
Netflix는 다음과 같이 실패에 대해 처리한다.

* **네트워크 타임아웃**: 응답에 대해 항상 Timeout 설정, 불필요한 리소스 사용 방지
* **미처리 요청 개수 제한**: 최대 요청 횟수를 설정하여 초과시 요청을 포기하도록 한다.
* **회로 차단기 패턴**: 서비스에 성공/실패에 대해서 counting을 하고 일정 임계치를 초과하면  그 이후에 요청은 포기한다.

부분 실패시 미리 정해진 default 값이나 캐시된 값 등을 반환하는 방법이 있다.

#  
## 서비스 디스커버리
클라우드 기반에 애플리케이션 구조는 네트워크가 동적(dhcp, 자동확장, 업그레이드 등)이라 인스턴스 별로 
식별하기 위해서 서비스 디스커버리를 사용한다.

![3-2-1](https://raw.githubusercontent.com/sanggi-wjg/my_study/main/MicroServiceArchitecture/data/3-2-1.PNG)

서비스 디스커버리 기능은 **인스턴스의 네트워크 위치를 DB화 한 서비스 레지스트리** 이다.
인스턴스가 시작/종료 마다 서비스 레지스트리는 업데이트 되고 
Client가 서비스 호출시 가용 목록 중 한 서비스로 라우팅을 한다.

## 디스커버리 사용 두가지 방법
1. Client/Service  가 직접 서비스 레지스트리와 상호 작용
1. 배포 인프라를 이용해 서비스 디스커버리를 처리

### Client/Service 직접 상호작용
서비스 인스턴스는 자신의 네트워크 IP를 서비스 레지스트리에 등록 API로 등록.  
서비스 레지스트리는 주기적인 Health Check 와 heartbeat 한다.(라이브러리마다 다름)  
서비스 클라이언트는 쿼리 API로 서비스 인스턴스 목록을 가져와서 round-robin 등의 분산 알고리즘을 이용하여  
한개의 서비스 인스턴스로 요청을 라우팅
![3-2-2](https://raw.githubusercontent.com/sanggi-wjg/my_study/main/MicroServiceArchitecture/data/3-2-2.PNG)

### 배포 인프라 이용
도커나 쿠버네티스 등 배포 플랫폼은 이미 서비스 레지스트리, 서비스 디스커버리 기능이 있다.  
방법은 서비스 Client는 요청시 배보 플랫폼이 알아서 라우팅을 하도록 한다.   
![3-2-3](https://raw.githubusercontent.com/sanggi-wjg/my_study/main/MicroServiceArchitecture/data/3-2-3.PNG)

이 방법은 다음 두가지의 패턴이 필요하다.
* **서드파티 등록 패턴(네트워크 등록기)** : 서비스 레지스트리에 등록기가 네트워크 등록을 작업.  
(이것은 인스턴스에서 진행하지 않는다.)
* **서버쪽 디스커버리 패턴(플랫폼 라우터)** : 클라이언트가 서비스 레지스트리에 쿼리하지 않고 DNS 를 요청.

저자는 배포 인프라를 이용한 방법을 권장. 